## Context

当前项目中，`crypto.ts` 和 `masterKey.ts` 分别负责加密操作和主密钥管理。两个模块已有独立的单元测试：
- `crypto.ts`: 测试加密/解密函数、输入验证、边界情况（crypto-utils-coverage, crypto-validation-tests, crypto-edge-cases）
- `masterKey.ts`: 测试密钥生成、存储、获取、初始化（master-key-unit-tests）

但缺乏集成测试验证两个模块协同工作时的正确性。在实际应用中，主密钥的生命周期（生成→存储→获取→使用）与加密/解密操作紧密耦合，需要端到端测试确保集成场景的正确性。

测试框架使用 Vitest，已通过 `vi.mock()` 实现了 Keyring 的 Mock（`@/utils/tauriCompat`），可以隔离外部依赖。

## Goals / Non-Goals

**Goals:**
- 验证使用 `generateMasterKey()` 生成的密钥可以成功进行加密/解密操作
- 验证 `initializeMasterKey()` 获取的密钥与加密/解密功能的集成
- 测试密钥丢失或重新生成后的错误处理（旧数据无法解密）
- 验证密钥导出功能与加密操作的兼容性
- 测试 Tauri 和 Web 环境下的集成行为（通过 Mock 模拟）

**Non-Goals:**
- 不测试 crypto.ts 的内部实现细节（由现有单元测试覆盖）
- 不测试 masterKey.ts 的内部实现细节（由现有单元测试覆盖）
- 不测试 Keyring 的具体存储机制（由 Mock 隔离）
- 不测试加密算法的正确性（由 Web Crypto API 保证）

## Decisions

**1. 测试文件位置**
- **决定**: 将集成测试放在 `src/utils/__tests__/crypto-masterkey.integration.test.ts`
- **理由**: 
  - 遵循项目约定（已有 `src/store/keyring/__tests__/` 结构）
  - 测试同时涉及两个模块，放在 utils 的测试目录下便于维护
  - 使用 `.integration.` 后缀区分单元测试和集成测试
- **替代方案**: 
  - 放在 `src/store/keyring/__tests__/` ❌（测试范围超出 keyring）
  - 放在 `src/__tests__/` ❌（层级过深，不符合项目结构）

**2. Mock 策略**
- **决定**: 复用 masterKey 单元测试的 Mock 逻辑，mock `@/utils/tauriCompat` 模块
- **理由**: 
  - 保持测试隔离性，不依赖真实 Keyring
  - 复用现有 Mock 代码，避免重复
  - Mock 提供可控的测试场景（成功、失败、异常）
- **替代方案**: 
  - 使用真实 Keyring ❌（测试不稳定，依赖系统状态）
  - Mock Web Crypto API ❌（测试目标是集成，非加密算法本身）

**3. 测试用例设计**
- **决定**: 使用场景化测试（Scenario-based testing），每个测试场景描述一个端到端流程
- **理由**: 
  - 集成测试关注"功能协同"而非"代码覆盖"
  - 场景化描述更易读和维护
  - 每个场景可独立运行，便于调试
- **替代方案**: 
  - 单元测试风格（逐一调用函数）❌（无法体现集成流程）
  - 性能测试风格（benchmark）❌（非本次目标）

**4. 密钥重新生成场景测试**
- **决定**: 测试密钥重新生成后，使用旧密钥加密的数据无法解密
- **理由**: 
  - 验证实际应用中的重要场景（用户清理数据后）
  - 确保 AES-GCM 认证标签机制正常工作
  - 提供用户友好的错误消息
- **替代方案**: 
  - 不测试此场景 ❌（遗漏关键错误处理路径）

**5. Tauri vs Web 环境测试**
- **决定**: 通过 Mock `isTauri()` 返回值测试两种环境的行为差异
- **理由**: 
  - 两个模块在 Tauri/Web 环境的错误消息不同
  - 验证环境检测逻辑正确性
  - 确保错误消息符合用户预期
- **替代方案**: 
  - 仅测试 Tauri 环境 ❌（Web 环境是重要使用场景）
  - 仅测试 Web 环境 ❌（桌面版是主要目标）

## Risks / Trade-offs

**1. 测试不稳定风险**
- **风险**: Mock 配置不当可能导致测试失败（如 Keyring 返回值不符合预期）
- **缓解**: 
  - 使用 `beforeEach` 和 `afterEach` 重置 Mock 状态
  - 每个测试用例独立配置 Mock 返回值
  - 添加清晰的断言错误消息

**2. 测试覆盖率不足风险**
- **风险**: 集成测试可能无法覆盖所有边界情况
- **缓解**: 
  - 集成测试关注"快乐路径"和"关键错误场景"
  - 边界情况由现有单元测试覆盖
  - 测试文档明确说明集成测试的范围

**3. 测试维护成本**
- **风险**: 随着代码演进，集成测试可能需要频繁更新
- **缓解**: 
  - 测试用例设计为"黑盒"测试（关注输入输出，非实现细节）
  - 使用场景化描述，降低代码变更对测试的影响
  - 定期审查测试用例的必要性

**4. Mock 与真实行为差异**
- **风险**: Mock 的行为可能与真实 Keyring 不一致
- **缓解**: 
  - Mock 实现尽量贴近真实 API（返回值类型、错误场景）
  - 端到端测试（E2E）覆盖真实场景（如果项目有 E2E 测试）
  - 定期手动验证 Mock 行为的正确性

## Migration Plan

**测试部署步骤**:
1. 创建测试文件 `src/utils/__tests__/crypto-masterkey.integration.test.ts`
2. 实现 Mock 配置（复用 masterKey 单元测试的 Mock 逻辑）
3. 实现测试用例（按 specs 定义的场景）
4. 运行测试验证：`pnpm test crypto-masterkey.integration.test.ts`
5. 检查测试覆盖率（集成测试不强制覆盖率要求）
6. 提交代码

**回滚策略**:
- 测试文件失败不影响生产代码，可直接删除测试文件
- 如果 Mock 配置影响其他测试，检查 `vi.clearAllMocks()` 调用
- 如果测试不稳定，使用 `test.skip()` 跳过问题用例，修复后启用

## Open Questions

1. **测试超时设置**: 集成测试可能涉及异步操作，是否需要增加测试超时时间？
   - **建议**: 使用默认超时（Vitest 默认 5000ms），加密操作通常很快

2. **测试数据管理**: 是否需要使用固定的测试密钥（fixture），还是每次生成新密钥？
   - **建议**: 每次生成新密钥，测试密钥生成的随机性和正确性

3. **错误场景覆盖**: 是否需要测试 Keyring 完全不可用的场景（如 IndexedDB 损坏）？
   - **建议**: 由 masterKey 单元测试覆盖，集成测试关注"密钥存在"的场景

4. **性能测试**: 是否需要测试大规模数据的加密/解密性能？
   - **建议**: 不包含在本次集成测试中（性能测试独立规划）
