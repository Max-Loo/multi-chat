# 增强聊天服务原始信息收集 - 技术设计

## Context

当前 `chatService.ts` 在保存聊天消息时，`raw` 字段被硬编码为空字符串，导致供应商 API 返回的原始响应数据丢失。这些数据对于调试、成本优化、推理模型支持、供应商差异分析、审计日志和 RAG 来源追踪等场景至关重要。

随着支持模型供应商增多、推理模型（如 DeepSeek-R1、K1 等）普及，以及 RAG 功能需求增加，保留原始 API 响应的需求变得更加迫切。

**当前状态**：
- `StandardMessage.raw` 字段类型为 `string | null`
- `streamChatCompletion()` 函数中 `raw` 字段始终为空字符串
- 依赖 Vercel AI SDK (`ai`) 包与供应商 API 交互
- 使用字段级加密（AES-256-GCM）存储聊天数据

**约束条件**：
- 必须保持向后兼容性（旧消息的 `raw` 为空字符串或 `null`）
- 必须考虑存储空间和加密性能影响
- 必须过滤敏感信息（API Key、Authorization 头等）
- 需要支持 DeepSeek、MoonshotAI、Zhipu 三个供应商的差异化字段

## Goals / Non-Goals

**Goals:**
1. 收集完整的供应商 API 原始响应数据，包括请求/响应元数据、Token 使用详情、供应商特定字段
2. 实现流式事件统计（文本增量计数、推理增量计数、耗时）
3. 支持 RAG 来源信息收集（web search RAG 模型的 sources 字段）
4. 确保数据安全（过滤敏感信息、加密存储）
5. 保持向后兼容性（旧消息和新消息共存）
6. 提供类型安全的访问接口（类型守卫、格式化函数）

**Non-Goals:**
1. 不修改消息存储的核心加密逻辑（复用现有的字段级加密）
2. 不实现完整的 UI 层展示（仅提供格式化函数，UI 实现属于后续工作）
3. 不实现数据压缩功能（在存储空间成为瓶颈前不引入压缩复杂度）
4. 不实现工具调用支持（为未来功能预留字段，但不实现）
5. 不修改聊天消息的其他字段（仅修改 `raw` 字段）

## Decisions

### 决策 1：使用结构化对象而非字符串存储 `raw` 数据

**选择**：将 `StandardMessage.raw` 字段类型从 `string | null` 改为 `StandardMessageRawResponse | null`，其中 `StandardMessageRawResponse` 是包含所有原始响应数据的结构化对象。

**理由**：
- **类型安全**：TypeScript 类型系统提供编译时检查，减少运行时错误
- **代码可读性**：结构化对象的访问比解析 JSON 字符串更直观
- **字段访问便利性**：可以直接访问 `raw.response.id` 而非 `JSON.parse(raw).response.id`
- **与 Vercel AI SDK 对齐**：ai-sdk 返回的元数据已经是对象形式，直接映射更自然

**替代方案**：
- 继续使用字符串，存储 JSON 序列化后的原始数据
  - 缺点：需要额外的序列化/反序列化逻辑，失去类型安全
- 使用二进制格式（如 MessagePack）
  - 缺点：引入新的依赖，增加复杂度，类型支持不完善

### 决策 2：通过 Vercel AI SDK 统一接口收集元数据

**选择**：依赖 Vercel AI SDK (`ai`) 包的标准化接口收集原始响应数据，而非直接调用供应商 API。

**理由**：
- **供应商无关性**：ai-sdk 已经处理了不同供应商之间的差异（如 DeepSeek、MoonshotAI、Zhipu）
- **维护成本**：供应商 API 变更时，ai-sdk 会更新，无需修改项目代码
- **代码简洁**：ai-sdk 提供的接口（如 `result.usage`、`result.response`）已经标准化
- **功能完整性**：ai-sdk 提供了完整的元数据（request、response、usage、providerMetadata、warnings、sources 等）

**替代方案**：
- 直接调用供应商 API，手动解析响应
  - 缺点：需要为每个供应商编写解析逻辑，维护成本高，容易出错
- 混合使用 ai-sdk 和直接调用
  - 缺点：增加复杂度，失去 ai-sdk 的统一优势

### 决策 3：在流式处理中增量收集事件，在最终消息中保存完整元数据

**选择**：在 `streamChatCompletion()` 的流式处理循环中统计 `text-delta` 和 `reasoning-delta` 事件数量，在流结束后收集完整的元数据（response、request、usage 等），并在最终 yield 的消息中包含完整的 `raw` 对象。

**理由**：
- **用户体验**：流式消息可以实时显示内容，无需等待元数据收集完成
- **性能优化**：元数据收集（如 `await metadata.response`）是异步操作，在流结束后并行执行不影响用户体验
- **数据完整性**：最终消息包含完整的元数据，可用于存储和分析
- **与现有逻辑一致**：现有的流式处理逻辑已经是增量 yield，最终 yield 完整消息（包括 finishReason 和 usage）

**替代方案**：
- 在每个增量消息中都包含完整的元数据
  - 缺点：元数据收集是异步操作，会阻塞流式处理，影响用户体验
- 只在流结束后 yield 一条包含元数据的消息
  - 缺点：用户无法实时看到响应内容

### 决策 4：使用渐进式实现策略，优先实现核心功能

**选择**：将实现分为三个阶段：
- **阶段 1（必须实现）**：基础数据收集（response、request、usage、finishReason）
- **阶段 2（推荐实现）**：增强数据收集（headers、tokenDetails、providerMetadata、warnings、streamStats、sources）
- **阶段 3（可选实现）**：高级特性（usage.raw、steps、files）

**理由**：
- **风险控制**：先实现核心功能，验证可行性后再扩展
- **迭代开发**：可以逐步测试和验证，降低调试难度
- **灵活性**：根据实际需求调整优先级

**替代方案**：
- 一次性实现所有字段
  - 缺点：开发周期长，测试难度大，风险高

### 决策 5：在保存前过滤敏感信息，而非在 UI 层过滤

**选择**：在 `chatService.ts` 中构建 `raw` 对象时，立即过滤敏感信息（如 `request.body` 中的 API Key、`response.headers` 中的 Authorization 头），确保存储的数据不包含敏感信息。

**理由**：
- **安全第一**：防止敏感信息泄露到存储层，即使 UI 层有漏洞也不会泄露
- **数据一致性**：确保存储和展示的数据一致，避免"存储了但不能展示"的情况
- **简化 UI 逻辑**：UI 层无需处理敏感信息过滤，专注于展示

**替代方案**：
- 在 UI 层过滤敏感信息
  - 缺点：存储层仍包含敏感信息，存在泄露风险
- 在读取时过滤敏感信息
  - 缺点：增加读取逻辑复杂度，且无法保证所有读取路径都过滤

## Risks / Trade-offs

### 风险 1：存储空间增加

**风险描述**：每条消息的 `raw` 数据约增加 1-6 KB（未压缩），假设用户有 1000 条历史消息，额外占用约 1-4 MB。

**缓解措施**：
- **数据清理**：移除 `headers` 中的敏感信息和重复字段，限制 `body` 大小（超过 10KB 时截断）
- **选择性存储**：通过配置项控制是否保存完整的 `request.body` 和 `response.headers`（后续迭代）
- **延迟加载**：UI 层按需加载 `raw` 数据（如点击"查看详细信息"时），不默认加载
- **监控**：添加存储空间监控，当用户存储空间超过阈值时提示清理

**权衡**：存储空间增加换取调试和审计能力，对于大多数用户是可接受的

### 风险 2：加密性能影响

**风险描述**：`raw` 数据会被加密存储，加密时间与数据大小成正比。假设每条消息增加 3KB，加密时间可能增加 10-20%。

**缓解措施**：
- **性能测试**：在实现后进行加密性能测试，确保影响在可接受范围内（<20%）
- **异步加密**：确保加密操作不阻塞 UI 线程（使用 Web Crypto API，已经是异步）
- **选择性加密**：对于历史消息，可以选择只加密关键字段（后续迭代）

**权衡**：加密性能影响换取数据安全，符合项目的安全设计原则

### 风险 3：供应商差异导致的数据不一致

**风险描述**：不同供应商（DeepSeek、MoonshotAI、Zhipu）返回的元数据字段可能不一致，某些字段在某个供应商中不存在（如 `reasoningTokens` 仅在推理模型中存在）。

**缓解措施**：
- **使用 ai-sdk 标准化接口**：依赖 ai-sdk 的统一字段（如 `usage.inputTokens`），避免直接访问供应商特定字段
- **类型定义使用可选字段**：`StandardMessageRawResponse` 中的所有嵌套字段都是可选的（`?`），确保不存在的字段不会导致运行时错误
- **提供默认值**：在访问可选字段时使用 `??` 提供默认值
- **供应商特定字段**：通过 `providerMetadata` 保留供应商特定字段，不影响标准字段

**权衡**：接受供应商差异，通过类型系统和默认值处理不一致性

### 风险 4：向后兼容性问题

**风险描述**：旧消息的 `raw` 字段为空字符串或 `null`，新消息为结构化对象。UI 层需要同时支持两种格式，可能导致类型错误或显示异常。

**缓解措施**：
- **类型守卫**：提供 `isEnhancedRawResponse(raw)` 函数，用于判断 `raw` 是否为新格式
- **格式化函数**：提供 `formatRawResponse(raw)` 函数，统一处理两种格式的显示
- **UI 层适配**：UI 层在使用 `raw` 数据前，先调用类型守卫判断格式
- **测试覆盖**：添加向后兼容性测试，确保旧消息正常显示

**权衡**：增加类型守卫和格式化函数的复杂度，换取平滑的升级路径

### 风险 5：RAG Sources 数据的可用性依赖供应商

**风险描述**：`sources` 字段仅在部分模型（如 web search RAG 模型）中存在，普通聊天消息中该字段为 `undefined`。

**缓解措施**：
- **类型定义使用可选字段**：`sources` 字段是可选的，确保不存在时不会导致运行时错误
- **UI 层条件渲染**：仅在 `sources` 存在时显示来源信息
- **测试覆盖**：添加测试用例，验证无 sources 的普通聊天消息不影响数据收集

**权衡**：接受 `sources` 字段的可选性，通过类型系统和条件渲染处理

## Migration Plan

### 部署步骤

1. **阶段 1：代码修改**
   - 在 `src/types/chat.ts` 中新增 `StandardMessageRawResponse` 接口和类型守卫
   - 修改 `src/services/chatService.ts` 中的 `streamChatCompletion()` 函数
   - 更新测试文件（`src/__tests__/services/chatService.test.ts`）
   - 运行测试，确保功能正常

2. **阶段 2：灰度发布**
   - 在开发环境验证功能
   - 在测试环境验证性能（加密时间、存储空间）
   - 发布到生产环境（小范围用户）

3. **阶段 3：全量发布**
   - 监控生产环境的错误率和性能指标
   - 如果指标正常，全量发布
   - 如果指标异常，回滚到旧版本

4. **阶段 4：数据清理（可选）**
   - 对于旧消息，可以选择保留 `raw` 为空字符串或 `null`
   - 对于新消息，自动使用结构化的 `StandardMessageRawResponse`
   - 无需数据迁移（两种格式共存）

### 回滚策略

如果新版本出现严重问题，回滚步骤：
1. 恢复 `StandardMessage.raw` 字段类型为 `string | null`
2. 恢复 `streamChatCompletion()` 函数中的 `raw` 字段为空字符串
3. 重新发布旧版本
4. 已生成的新消息（包含结构化 `raw` 数据）会显示"无原始数据"或格式化后的 JSON，不影响基本功能

**注意事项**：
- 回滚后，新消息的 `raw` 数据会丢失（但消息内容不受影响）
- 旧消息的 `raw` 数据不受影响
- 确保回滚前备份生产数据

## Open Questions

1. **是否需要实现数据压缩功能？**
   - 当前决策：不实现（存储空间在可接受范围内）
   - 后续评估：如果用户反馈存储空间不足，可以考虑 gzip 压缩

2. **是否需要实现选择性存储配置？**
   - 当前决策：不实现（优先实现核心功能）
   - 后续评估：如果用户反馈加密性能影响大，可以考虑添加配置项

3. **UI 层如何展示 `raw` 数据？**
   - 当前决策：提供格式化函数，UI 实现属于后续工作
   - 后续评估：根据用户需求设计 UI（如"查看详细信息"按钮、开发者模式开关）

4. **是否需要支持导出 `raw` 数据？**
   - 当前决策：不实现（优先实现核心功能）
   - 后续评估：如果用户需要审计日志，可以考虑导出功能

5. **如何处理 `sources` 字段的验证？**
   - 当前决策：信任供应商返回的数据，不做验证
   - 后续评估：如果发现 `sources` 数据格式不一致，可以添加验证逻辑
