## Context

当前项目是一个使用 React + TypeScript + Tauri 的桌面应用程序。随着项目发展，代码库中可能积累了大量未使用的代码，包括：
- 废弃的组件和工具函数
- 早期开发遗留的类型定义
- 未被引用的变量和导入
- 测试代码中的冗余代码

这些死代码增加了维护成本，延长了编译时间，并可能误导新开发者。

## Goals / Non-Goals

**Goals:**
- 系统性地识别整个项目中的未使用代码
- 提供安全的自动化删除工具
- 建立防止死代码积累的机制
- 保持代码库的整洁和可维护性

**Non-Goals:**
- 修改代码逻辑或功能
- 重构现有代码结构
- 优化性能（这是副作用，不是主要目标）
- 检测运行时未使用的代码（仅关注静态分析）

## Decisions

### 1. 使用 `knip` 作为代码分析工具
**决策**: 使用 `knip` 而非 `ts-prune` 或 `depcheck`

**理由**:
- `knip` 支持检测更多类型的未使用代码（函数、类型、导入、导出、依赖等）
- 对 TypeScript 和 monorepo 有更好的支持
- 提供可配置的忽略规则
- 支持自定义入口点配置

**替代方案**:
- `ts-prune`: 仅支持检测未使用的导出，功能较单一
- `depcheck`: 主要检测未使用的 npm 依赖，不适用于源代码分析

### 2. 分层删除策略
**决策**: 采用"检测 → 确认 → 删除 → 验证"的分层流程

**理由**:
- 避免误删：人工确认关键环节
- 可追溯性：保留检测报告供审计
- 安全性：每次删除后自动运行验证

**替代方案**:
- 全自动删除：风险过高，可能误删动态引用的代码

### 3. 配置文件驱动
**决策**: 使用 `.knip.json` 配置文件管理检测规则

**理由**:
- 可版本控制：规则变更可追踪
- 团队协作：所有开发者共享相同配置
- 灵活性：支持项目特定规则

### 4. 集成到 CI/CD
**决策**: 在 CI 流水线中添加代码分析检查

**理由**:
- 防止新的死代码进入代码库
- 自动化保障代码质量

## Risks / Trade-offs

### [风险] 误删动态引用的代码
- **影响**: 某些代码可能通过字符串拼接或动态导入被引用，静态分析无法检测到
- **缓解**: 
  - 使用交互式删除模式，逐个确认
  - 删除前运行完整的测试套件
  - 提供恢复机制（通过 git）

### [风险] 误删公共 API
- **影响**: 库的公共 API 可能未被内部使用，但对外部消费者是必需的
- **缓解**:
  - 配置公共 API 目录的忽略规则
  - 在 Knip 配置中明确标记入口点

### [风险] 删除后测试覆盖率下降
- **影响**: 删除未使用的代码可能导致测试覆盖率统计不准确
- **缓解**:
  - 删除后重新运行覆盖率报告
  - 同时清理相关的测试代码

### [权衡] 扫描时间 vs. 检测精度
- **权衡**: 更深入的跨文件分析需要更长的扫描时间
- **决策**: 接受适度的扫描时间（< 30秒）以获得更高的检测精度

## Migration Plan

### 阶段 1: 初始扫描和报告 (第 1 周)
1. 安装并配置 `knip`
2. 运行全量扫描生成基线报告
3. 手动审查报告，识别明显的死代码

### 阶段 2: 安全删除 (第 2 周)
1. 批量删除明显安全的未使用代码（如未使用的导入）
2. 逐个确认删除复杂的未使用函数和类型
3. 每次删除后运行测试验证

### 阶段 3: CI 集成 (第 3 周)
1. 添加 CI 检查任务
2. 配置预提交钩子
3. 更新开发者文档

### 回滚策略
- 所有删除操作通过独立的 commit 进行
- 保留详细的删除日志
- 如有问题，通过 git revert 快速回滚

## Open Questions

1. 是否需要处理 `.d.ts` 声明文件中的未使用类型？
2. Storybook  stories 文件中的未使用组件如何处理？
3. 是否需要在删除前生成代码备份？
