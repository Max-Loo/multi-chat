## Context

当前项目中时间戳生成逻辑分散在多个位置：
- `src/services/chatService.ts:24-26`: 私有函数 `getCurrentTimestamp()` 返回 `Math.floor(Date.now() / 1000)`
- `src/store/slices/chatSlices.ts`: 直接使用 `Date.now() / 1000`
- 测试代码和 mock 数据中多处使用 `Date.now()`

这种分散的实现导致：
- 代码重复
- 缺乏统一的时间戳格式约定
- 维护成本高，容易引入单位混淆错误

## Goals / Non-Goals

**Goals:**
- 统一时间戳生成逻辑，消除代码重复
- 明确时间戳单位约定，避免混淆
- 提高代码可维护性和可测试性
- 为项目提供可复用的时间戳工具函数

**Non-Goals:**
- 不修改现有时间戳数据的格式或存储方式
- 不改变时间戳的语义（Unix 时间戳，秒级）
- 不强制替换所有测试代码中的时间戳生成（保留用于性能测试的原生 API）

## Decisions

### 1. 在 `utils.ts` 中添加时间戳函数（而非创建独立模块）

**决策**: 在现有的 `src/utils/utils.ts` 中添加时间戳函数，而不是创建新的 `timestamp.ts` 文件。

**理由**:
- `utils.ts` 已经是项目的通用工具函数库，符合其定位
- 时间戳生成是一个简单的工具函数，不需要独立模块
- 避免过度模块化，减少文件数量
- 导入路径更简洁：`@/utils/utils` 而非 `@/utils/timestamp`

**替代方案**:
- 创建独立的 `timestamp.ts`：适合时间戳功能复杂且需要多种相关函数的场景，但当前需求较简单，无需独立模块

### 2. 提供两个函数：秒级和毫秒级

**决策**: 同时提供 `getCurrentTimestamp()` 和 `getCurrentTimestampMs()` 两个函数。

**理由**:
- 项目中有不同精度需求（聊天消息使用秒级，某些场景可能需要毫秒级）
- 通过函数名称明确表达单位，避免混淆
- 保持向后兼容，便于不同场景选择合适的精度

**替代方案**:
- 只提供秒级函数：某些需要毫秒精度的场景需要自己计算，降低便利性
- 使用参数控制精度：`getCurrentTimestamp({ unit: 'seconds' | 'milliseconds' })` - 增加调用复杂度

### 3. 使用 `Math.floor()` 而非 `Math.round()` 或位运算

**决策**: 秒级时间戳使用 `Math.floor(Date.now() / 1000)`。

**理由**:
- 与现有代码保持一致
- `floor()` 确保时间戳单调递增，避免同一秒内出现未来时间戳
- 位运算（`Date.now() / 1000 | 0`）虽然更快，但可读性较差，且性能差异可忽略不计

### 4. 函数命名约定

**决策**:
- 秒级: `getCurrentTimestamp()` - 简洁名称，因为秒级是项目中最常用的格式
- 毫秒级: `getCurrentTimestampMs()` - 添加 `Ms` 后缀明确区分

**理由**:
- 符合项目现有命名风格（如 `getStandardRole`）
- 名称清晰表达返回值单位
- 避免使用 `timestamp` 和 `timestampMs`，因为它们看起来像变量而非函数

### 5. 保留测试代码的原生 API 使用

**决策**: 测试代码（特别是性能测试）中保留直接使用 `Date.now()` 的做法。

**理由**:
- 性能测试需要测量时间差，使用原生 API 减少函数调用开销
- Mock 数据生成可能需要精确控制时间戳，使用原生 API 更灵活
- 测试代码不遵循生产代码的 DRY 原则是可接受的

## Risks / Trade-offs

### 风险 1: 类型不匹配
**风险**: 某些代码可能隐式依赖特定的时间戳格式（如毫秒级），替换为秒级函数后导致错误。

**缓解措施**:
- 在替换前检查所有时间戳使用场景，确认格式要求
- 运行完整的测试套件，确保行为一致
- 在代码审查时特别关注时间戳相关的类型和使用

### 风险 2: 导入路径变更
**风险**: 如果 `chatService.ts` 已经有其他从 `@/utils/utils` 的导入，可能需要合并导入语句。

**缓解措施**:
- 在实现时检查现有的导入语句
- 使用 TypeScript 的导入合并或统一导入风格

### 权衡 1: 代码复用 vs 简洁性
**权衡**: 提取函数会增加一层抽象，但提高了代码复用性和一致性。

**决策**: 选择提取函数，因为当前存在明显的代码重复问题。

### 权衡 2: 灵活性 vs 约束
**权衡**: 统一函数约束了时间戳生成方式，但减少了错误的可能性。

**决策**: 选择约束，通过统一的 API 确保一致性，特殊需求仍可使用原生 API。

## Migration Plan

1. **在 `utils.ts` 中添加函数**
   - 实现 `getCurrentTimestamp()` 和 `getCurrentTimestampMs()`
   - 添加 JSDoc 注释说明返回值单位

2. **替换生产代码**
   - `chatService.ts`: 删除私有函数，使用导入的工具函数
   - `chatSlices.ts`: 替换 `Date.now() / 1000` 为 `getCurrentTimestamp()`
   - `keyring.ts`: 根据需求决定是否替换（当前使用毫秒，可用 `getCurrentTimestampMs()`）

3. **添加测试**
   - 为新函数添加单元测试，验证返回值格式和范围
   - 运行现有测试，确保替换后行为一致

4. **文档更新**
   - 在 AGENTS.md 或相关文档中明确时间戳单位约定
   - 在类型注释中说明 `timestamp` 字段为秒级 Unix 时间戳

**回滚策略**: 如果出现严重问题，可以快速回滚到原有实现，因为变更范围有限且独立。

## Open Questions

1. **是否需要替换 `keyring.ts` 中的 `Date.now()`？**
   - 当前使用毫秒级时间戳，可替换为 `getCurrentTimestampMs()`
   - 建议：在实施时评估该处时间戳的用途，如果是用于调试而非业务逻辑，可保持原样

2. **是否需要添加时区支持？**
   - 当前函数只返回 UTC 时间戳，不涉及时区转换
   - 建议：不在本次变更中实现时区功能，保持简洁。如有需要，后续可添加独立的日期时间工具
