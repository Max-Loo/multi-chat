# Crypto 边界条件测试规范

## ADDED Requirements

### Requirement: 加密解密大数据量测试

系统 SHALL 测试加密/解密函数在处理大数据时的性能和正确性。

#### Scenario: 超长文本加密解密

- **WHEN** 加密超长文本（如 > 1MB 的文本，重复字符串 100000 次）
- **THEN** 系统应成功完成加密
- **AND** 系统应成功解密
- **AND** 解密后的文本应与原始明文完全一致
- **AND** 操作应在合理时间内完成（< 1秒）

#### Scenario: 大量重复数据加密唯一性

- **WHEN** 使用相同密钥和相同明文多次加密（如 100 次）
- **THEN** 每次加密的结果应不同
- **AND** 所有密文都应能正确解密回原始明文
- **AND** 这证明随机 nonce 的有效性

### Requirement: 特殊 Unicode 字符处理

系统 SHALL 测试加密/解密函数对各种 Unicode 字符的处理能力。

#### Scenario: 中日韩字符

- **WHEN** 加密包含中文字符（"你好世界"）、日文字符（"こんにちは"）、韩文字符（"안녕하세요"）的文本
- **THEN** 系统应正确使用 UTF-8 编码加密
- **AND** 解密后应完整恢复原始字符

#### Scenario: Emoji 字符

- **WHEN** 加密包含各种 emoji 的文本（如 "🔐🔑🚀💻🌍"）
- **THEN** 系统应正确处理多字节 Unicode 字符
- **AND** 解密后应完整恢复所有 emoji

#### Scenario: 组合字符和变体符号

- **WHEN** 加密包含组合字符（如 "é" 可以是 "e" + "́"）或变体符号的文本
- **THEN** 系统应正确处理 Unicode 规范化
- **AND** 解密后应保持原始字符表示

#### Scenario: 从左到右和从右到左混合文本

- **WHEN** 加密包含从左到右（如英文）和从右到左（如阿拉伯文 "مرحبا"）混合的文本
- **THEN** 系统应正确处理双向文本
- **AND** 解密后应保持正确的显示顺序

### Requirement: 特殊 ASCII 字符处理

系统 SHALL 测试加密/解密函数对特殊 ASCII 字符的处理。

#### Scenario: 控制字符

- **WHEN** 加密包含控制字符的文本（如换行符 `\n`、制表符 `\t`、回车符 `\r`）
- **THEN** 系统应正确处理控制字符
- **AND** 解密后应保留所有控制字符

#### Scenario: 多行文本

- **WHEN** 加密包含多行的文本（使用 `\n` 分隔）
- **THEN** 系统应正确加密多行内容
- **AND** 解密后应保持原始行结构

#### Scenario: 特殊符号和标点

- **WHEN** 加密包含各种特殊符号的文本（如 "!@#$%^&*()_+-=[]{}|;':\",./<>?"）
- **THEN** 系统应正确处理所有可打印 ASCII 字符
- **AND** 解密后应完整恢复

#### Scenario: 零字符（null byte）

- **WHEN** 加密包含零字符 `\0` 的文本
- **THEN** 系统应正确处理零字符
- **AND** 解密后应包含零字符（虽然在 JavaScript 字符串中不可见）

### Requirement: 密钥边界情况测试

系统 SHALL 测试密钥的各种边界情况。

#### Scenario: 密钥最小有效长度

- **WHEN** 使用正好 64 个 hex 字符的密钥（256 位）
- **THEN** 系统应成功导入密钥并完成加密/解密

#### Scenario: 密钥所有位为 0

- **WHEN** 使用全部为 "0" 的 64 字符 hex 密钥（"0".repeat(64)）
- **THEN** 系统应成功导入密钥
- **AND** 加密/解密应正常工作（虽然不安全）

#### Scenario: 密钥所有位为 f

- **WHEN** 使用全部为 "f" 的 64 字符 hex 密钥（"f".repeat(64)）
- **THEN** 系统应成功导入密钥
- **AND** 加密/解密应正常工作

#### Scenario: 密钥大小写混合

- **WHEN** 使用大小写混合的 hex 密钥（如 "AaBbCc..."）
- **THEN** 系统应正确解析 hex 字符
- **AND** 加密/解密应正常工作

### Requirement: 密文边界情况测试

系统 SHALL 测试密文的各种边界情况。

#### Scenario: 最小有效密文

- **WHEN** 加密空字符串
- **THEN** 产生的密文应包含 "enc:" 前缀
- **AND** 密文长度应大于 4
- **AND** 应能成功解密

#### Scenario: 非 Base64 字符在 enc: 后

- **WHEN** 输入 "enc:" 后跟非 Base64 字符的字符串
- **THEN** `atob()` 应抛出异常
- **AND** 系统应返回友好的错误消息

#### Scenario: 截断的 Base64 数据

- **WHEN** 输入 "enc:" 后跟被截断的 Base64 字符串（缺少填充）
- **THEN** 系统应尝试解码
- **AND** 可能失败或产生无效数据
- **AND** 后续解密应失败并返回错误消息

### Requirement: 加密算法特性测试

系统 SHALL 测试 AES-256-GCM 算法的特定特性。

#### Scenario: 认证标签验证

- **WHEN** 解密时修改密文中的任何字节
- **THEN** AES-GCM 的认证标签验证应失败
- **AND** 系统应抛出解密失败错误
- **AND** 不应返回错误明文

#### Scenario: nonce 唯一性

- **WHEN** 多次加密相同明文
- **THEN** 每次生成的 nonce（12 字节）应不同
- **AND** 这由 `crypto.getRandomValues()` 保证

#### Scenario: 密钥重用安全

- **WHEN** 使用相同密钥加密不同明文
- **THEN** 每次加密的结果应不同
- **AND** 这由随机 nonce 保证（AES-GCM 的要求）

### Requirement: 性能边界测试

系统 SHALL 测试加密/解密函数的性能边界。

#### Scenario: 单个字符加密解密

- **WHEN** 加密单个字符
- **THEN** 操作应瞬间完成
- **AND** 不应出现性能问题

#### Scenario: 中等文本加密解密

- **WHEN** 加密中等长度文本（如 10KB）
- **THEN** 操作应在毫秒级完成
- **AND** 不应出现明显的延迟

#### Scenario: 连续多次加密解密

- **WHEN** 连续执行 1000 次加密/解密操作
- **THEN** 所有操作应在合理时间内完成（< 5秒）
- **AND** 不应出现内存泄漏

### Requirement: 并发和异步测试

系统 SHALL 测试加密/解密函数的异步特性。

#### Scenario: 并发加密操作

- **WHEN** 同时启动多个加密操作（使用 Promise.all）
- **THEN** 所有操作应独立完成
- **AND** 所有结果应使用不同的 nonce
- **AND** 所有结果都应能正确解密

#### Scenario: 加密解密顺序无关性

- **WHEN** 先加密数据，稍后解密（甚至在不同事件循环中）
- **THEN** 解密应始终成功
- **AND** 结果应与原始明文一致
