## Context

当前项目的三个关键模块测试覆盖率严重不足：
- **src/router**: 0% 覆盖率，路由配置和导航守卫逻辑未测试
- **src/components/Layout**: 0% 覆盖率，布局组件未测试
- **src/pages/Chat/components/ChatContent/components**: 8.13% 覆盖率，聊天内容组件群测试缺失

这些模块是应用的核心功能，路由管理控制页面导航，Layout 提供整体应用框架，ChatContent/components 负责聊天消息的渲染和交互。低测试覆盖率意味着代码质量和重构信心不足，任何修改都可能引入未知的 bug。

## Goals / Non-Goals

**Goals:**
- 为 router 模块添加全面的单元测试和集成测试，达到 80%+ 覆盖率
- 为 Layout 组件添加渲染和交互测试，达到 70%+ 覆盖率
- 为 ChatContent/components 组件群添加完整的组件测试，达到 80%+ 覆盖率
- 建立可维护的测试套件，确保长期质量保障
- 补充关键路径的测试覆盖，提升整体系统稳定性

**Non-Goals:**
- 不修改现有业务逻辑或功能实现
- 不引入新的测试框架或工具（使用现有的 Vitest 和 React Testing Library）
- 不添加 E2E 测试（聚焦于单元测试和组件测试）
- 不改变现有的代码结构（仅添加测试文件）

## Decisions

### 测试框架选择

**决定**: 继续使用现有的 Vitest + React Testing Library + MSW

**理由**:
- Vitest 是项目现有测试运行器，配置已完善，与 Vite 深度集成
- React Testing Library 是 React 组件测试的事实标准，强调用户视角测试
- MSW (Mock Service Worker) 用于模拟 API 请求，已在项目中配置
- 避免引入额外依赖，保持技术栈简洁

**替代方案**: Jest + React Testing Library
- 未采纳原因：Jest 与 Vite 集成需要额外配置，性能不如 Vitest

### 测试策略分层

**决定**: 采用测试金字塔策略，侧重单元测试和组件测试

**理由**:
- 单元测试：快速反馈，精准定位问题，适用于工具函数和纯逻辑
- 组件测试：验证组件渲染和交互，覆盖用户可见行为
- 集成测试：验证模块间协作，用于关键流程

**替代方案**: 大量 E2E 测试
- 未采纳原因：E2E 测试维护成本高、执行慢，不适合快速迭代

### 覆盖率工具

**决定**: 使用 Vitest 内置的覆盖率工具（基于 c8）

**理由**:
- 无需额外配置，开箱即用
- 与现有 CI/CD 流程集成简单
- 支持 HTML 报告生成，便于可视化分析

**替代方案**: Istanbul
- 未采纳原因：需要额外配置，Vitest 内置工具已满足需求

### Mock 策略

**决定**: 根据测试类型采用不同的 Mock 策略

**单元测试**:
- Mock 所有外部依赖（API、文件系统、时间）
- 使用 Vitest 的 `vi.fn()` 和 `vi.mock()`

**组件测试**:
- Mock API 请求（使用 MSW）
- Mock 路由上下文（使用 MemoryRouter）
- 尽量避免实现细节 Mock，测试用户交互

**理由**: 平衡测试隔离性和真实度，避免过度 Mock 导致测试脆弱

### 测试数据管理

**决定**: 使用测试辅助工具和 fixtures 管理测试数据

**理由**:
- 项目已有 `src/__test__/helpers/` 目录，包含测试辅助函数
- 创建 fixtures 复用测试数据，保持测试代码简洁
- 避免在每个测试中重复构建相同的数据结构

### 测试文件组织

**决定**: 测试文件与源文件同目录或使用 `__tests__` 目录

**目录结构**:
```
src/__test__/
├── router/              # 路由测试
│   ├── routeConfig.test.ts
│   └── navigationGuards.test.ts
├── components/          # 组件测试
│   └── Layout.test.tsx
└── fixtures/            # 测试数据
    └── chatData.ts

src/pages/Chat/components/ChatContent/components/
├── MessageBubble.tsx
└── MessageBubble.test.tsx  # 组件测试就近放置
```

**理由**: 
- 核心模块测试集中在 `src/__test__/` 便于发现
- 组件测试就近放置便于维护
- 符合项目现有结构

### 覆盖率目标制定

**决定**: 根据模块复杂度和重要性制定差异化目标

**理由**:
- Router (80%+): 路由逻辑复杂但相对稳定，可达到高覆盖率
- Layout (70%+): 布局组件依赖较多 UI 库，部分行为难以测试
- ChatContent/components (80%+): 业务逻辑清晰，交互可测试性强

**替代方案**: 统一 80% 目标
- 未采纳原因：Layout 组件涉及大量 UI 渲染，过高的覆盖率目标会导致 Mock 复杂度增加

### 并行实施策略

**决定**: 采用子代理并行执行独立模块测试任务

**理由**:
- 三个测试模块（Router、Layout、ChatContent/components）完全独立，无代码冲突
- 并行执行可显著缩短总实施时间（理论最高可减少 60% 时间）
- 每个子代理专注于单一模块，提高专业度和效率
- 环境准备完成后，三个模块的测试可同时启动

**并行执行分组**:
- **串行阶段**: 环境准备（任务组 1）→ 必须最先完成
- **并行阶段**: 
  - 子代理 A: Router 模块测试（任务组 2）
  - 子代理 B: Layout 组件测试（任务组 3）
  - 子代理 C: ChatContent/components 组件群测试（任务组 4）
- **串行阶段**: 覆盖率验证（任务组 5）→ 需等待所有并行任务完成
- **并行阶段**: 文档更新（任务组 6）→ 可与测试编写并行进行
- **串行阶段**: 验收和清理（任务组 7）→ 最后执行

**协调机制**:
- 共享测试基础设施和 fixtures（由任务组 1 创建）
- 各子代理独立创建测试文件，避免文件路径冲突
- 定期同步测试覆盖率数据，确保目标达成
- 统一的代码风格和测试规范（在任务组 1 中定义）

**替代方案**: 单一代码串行执行所有任务
- 未采纳原因：耗时较长，不符合敏捷开发效率要求

## Risks / Trade-offs

### 测试维护成本

**风险**: 新增 50-80 个测试用例会增加代码维护负担

**缓解措施**:
- 编写可维护的测试代码，遵循 DRY 原则
- 使用 fixtures 和辅助函数减少重复
- 定期重构测试代码，移除冗余测试

### 测试执行时间

**风险**: 测试套件变大可能导致 CI/CD 流程变慢

**缓解措施**:
- 使用 Vitest 的并行测试功能
- 将慢速测试（如集成测试）标记为 `@slow`
- 优化 Mock 策略，避免不必要的等待

### 过度 Mock 导致测试脆弱

**风险**: 过度 Mock 可能导致测试通过但实际功能不正常

**缓解措施**:
- 遵循"测试用户行为，不测试实现细节"原则
- 优先使用真实组件，Mock 仅用于外部依赖
- 定期运行 E2E 测试验证整体功能

### 覆盖率数字游戏

**风险**: 追求数字目标而忽视测试质量

**缓解措施**:
- 聚焦关键路径和边界情况，而非盲目增加覆盖率
- Code Review 关注测试用例的有效性
- 定期审查测试套件，移除无效测试

### 交互组件测试复杂性

**风险**: ChatContent/components 包含复杂交互（如 Markdown 渲染、代码高亮），测试难度高

**缓解措施**:
- 拆分组件，降低单个组件的测试复杂度
- 使用快照测试验证渲染结果
- 对于第三方库（如代码高亮），主要测试集成接口

## Migration Plan

**步骤 1: 环境准备（串行，必须最先完成）**
- 确认 Vitest、React Testing Library、MSW 配置正确
- 创建测试辅助工具和 fixtures
- 设置覆盖率报告生成
- 定义测试代码规范和命名约定

**步骤 2-4: 并行实施阶段（三个子代理同时执行）**

**子代理 A - Router 模块测试**:
- 添加路由配置测试（`routeConfig.test.ts`）
- 添加导航守卫测试（`navigationGuards.test.ts`）
- 验证覆盖率目标达成（80%+）

**子代理 B - Layout 组件测试**:
- 添加布局渲染测试（`Layout.test.tsx`）
- 测试响应式行为
- 验证覆盖率目标达成（70%+）

**子代理 C - ChatContent/components 测试**:
- 为每个子组件添加测试
- 测试 Markdown 解析和代码高亮
- 测试用户交互行为
- 验证覆盖率目标达成（80%+）

**并行期间同步任务（可由任一子代理或独立子代理完成）**:
- 编写测试规范文档
- 更新 AGENTS.md 中的测试相关章节
- 添加测试运行脚本

**步骤 5: 覆盖率验证（串行，合并所有测试后）**
- 运行完整测试套件
- 生成覆盖率报告
- 验证所有模块覆盖率目标达成
- 补充遗漏的测试用例

**步骤 6: 验收和清理（串行，最后执行）**
- 运行 lint 和类型检查
- 检查测试代码质量
- 确保生产功能不受影响
- 生成测试覆盖率总结报告

**回滚策略**:
- 测试文件独立于源代码，不影响生产环境
- 如测试导致 CI 失败，可临时跳过测试步骤
- 保留测试文件的 Git 历史，便于回退

**协调机制**:
- 使用 Git 分支策略，各子代理在独立分支工作
- 定期同步共享 fixtures 和辅助工具
- 统一的代码审查标准
- 覆盖率数据实时共享

## Open Questions

1. **是否需要设置覆盖率门禁？**
   - 当前不强制，建议先完成测试，后续根据情况决定

2. **是否需要测试未导出的内部函数？**
   - 原则上不测试内部实现，如确需测试，考虑重构为独立工具函数

3. **如何测试第三方 UI 库组件（如 shadcn/ui）？**
   - 主要测试集成接口和交互行为，不测试第三方库本身

4. **是否需要添加性能测试？**
   - 当前不包含，如遇到性能问题可单独添加

5. **如何处理异步测试的时序问题？**
   - 使用 `waitFor` 和 `findBy*` 查询，避免固定延迟