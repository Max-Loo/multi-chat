# 技术设计：瀑布流布局实现

## Context

**当前状态**：
ProviderGrid 组件使用 CSS Grid 布局（`grid grid-cols-1 md:grid-cols-1 lg:grid-cols-2 xl:grid-cols-3`），在供应商卡片高度不一致时（展开/折叠状态不同）会产生大量垂直空白区域，影响空间利用率。

**背景**：
- 项目使用 React 19 + TypeScript + Tailwind CSS
- 已使用 shadcn/ui 组件库
- ProviderCard 组件支持展开/折叠，高度动态变化
- 当前响应式断点：md (768px), lg (1024px), xl (1280px)

**约束**：
- 必须保持现有响应式行为
- 不能影响卡片展开/折叠功能
- 需要保持良好的性能

## Goals / Non-Goals

**Goals**:
- 实现瀑布流布局，消除垂直空白区域
- 保持响应式列数配置（小屏幕 3 列，中等屏幕 1 列，超大屏幕 2 列）
- 支持卡片动态高度变化时自动重新布局
- 保持良好的渲染性能（500ms 内完成）

**Non-Goals**:
- 不修改 ProviderCard 组件的内部实现
- 不改变卡片展开/折叠的交互逻辑
- 不改变现有的国际化功能

## Decisions

### 决策 1：使用 react-masonry-css 库

**选择**：引入 `react-masonry-css` 库

**理由**：
- **成熟稳定**：该库在 GitHub 上有 1.7k+ stars，广泛使用
- **保持 DOM 顺序**：与 CSS Columns 不同，元素保持原始顺序，用户体验更好
- **响应式支持**：内置断点配置，易于实现响应式布局
- **TypeScript 支持**：提供完整的类型定义
- **轻量级**：包体积小（约 5KB gzipped）
- **无需复杂计算**：库自动处理布局计算，简化实现

**替代方案**：
- **CSS Columns**：
  - 优点：零依赖，原生 CSS
  - 缺点：DOM 顺序与视觉顺序不一致（垂直优先），可能导致用户困惑
- **纯 Flexbox 实现**：
  - 优点：完全控制
  - 缺点：需要手动计算列高度分配，实现复杂，维护成本高
- **虚拟滚动库（如 react-window）**：
  - 优点：性能最优
  - 缺点：过度设计，当前卡片数量通常 < 50，不需要虚拟化

### 决策 2：响应式断点映射

**选择**：
```typescript
const breakpointColumnsObj = {
  default: 3,  // 默认 3 列（适用于大屏幕）
  1560: 2,     // 超大屏幕（≥ 1560px）→ 2 列
  1024: 1,     // 中等屏幕（≥ 1024px）→ 1 列
};
```

**理由**：
- 自定义断点配置，根据实际展示需求调整
- 提供更细粒度的列数控制
- 适应不同屏幕尺寸的最佳阅读体验

**说明**：
- 小屏幕（< 1024px）：默认 3 列
- 中等屏幕（≥ 1024px）：1 列
- 超大屏幕（≥ 1560px）：2 列

### 决策 3：列间距实现方式

**选择**：使用负 margin + padding-left 组合

```tsx
<Masonry
  className="flex w-full -ml-4"     // 负 margin 抵消列 gap
  columnClassName="pl-4"              // padding-left 创建列间距
>
```

**理由**：
- react-masonry-css 推荐的最佳实践
- 使用 Tailwind 的 spacing scale（4 = 1rem）
- 避免自定义 CSS，保持一致性
- 支持响应式间距（可通过 tailwind 配置调整）

### 决策 4：卡片间距与完整性保护

**选择**：添加包装 div 来控制垂直间距和卡片完整性

**理由**：
- react-masonry-css 不直接支持垂直间距配置
- 使用包装 div 可以同时解决两个问题：
  1. 通过 `mb-4` 添加垂直间距（1rem）
  2. 通过 `break-inside-avoid` 确保卡片不被列边界分割
- 增加的 DOM 层级对性能影响可忽略不计

**实现**：
```tsx
<div key={provider.providerKey} className="mb-4 break-inside-avoid">
  <ProviderCard ... />
</div>
```

**注意事项**：
- 包装 div 不影响卡片原有的交互功能
- break-inside-avoid 确保卡片完整显示在单列内
- 测试确认卡片不会被跨列显示

## Risks / Trade-offs

### 风险 1：卡片展开时的布局跳动
**风险**：展开卡片时，该列的后续卡片会突然下移，可能影响用户体验

**缓解措施**：
- react-masonry-css 支持过渡动画，可在 CSS 中添加 transition
- 考虑添加淡入淡出效果（fade-in）
- 在设计文档中记录此行为，作为已知限制

### 风险 2：性能问题（大量卡片时）
**风险**：如果供应商数量增加到 > 100 个，布局计算可能影响性能

**缓解措施**：
- 当前实际使用场景通常 < 50 个供应商
- 如未来需要优化，可考虑引入虚拟滚动
- 在性能场景中添加监控和测试

### 风险 3：依赖库的维护风险
**风险**：react-masonry-css 可能不再维护或出现兼容性问题

**缓解措施**：
- 该库已稳定多年，最近仍有更新
- 如需要，替换为其他方案的改动成本可控（仅限 ProviderGrid.tsx）
- 在 package.json 中锁定版本，避免破坏性更新

### 权衡：DOM 顺序 vs 垂直紧凑度
**权衡**：react-masonry-css 保持 DOM 顺序，可能在极端情况下无法达到完美的垂直紧凑度

**分析**：
- 对于实际使用场景（卡片高度差异不会极大），DOM 顺序更符合用户预期
- 牺牲的紧凑度通常 < 5%，可接受的权衡

## Migration Plan

### 实施步骤

1. **安装依赖**
   ```bash
   pnpm add react-masonry-css
   ```

2. **修改 ProviderGrid.tsx**
   - 导入 Masonry 组件
   - 替换 CSS Grid 容器为 Masonry
   - 配置响应式断点
   - 添加间距样式

3. **测试验证**
   - 验证响应式布局（移动端、平板、桌面）
   - 测试卡片展开/折叠时的重新布局
   - 检查列间距是否正确
   - 验证卡片不会跨列显示
   - 性能测试（50 个卡片的渲染时间）

4. **代码审查**
   - 确保符合项目编码规范
   - 验证 TypeScript 类型正确
   - 检查无 console 警告或错误

5. **更新文档**
   - 更新 AGENTS.md（如果需要）
   - 不需要更新 README.md（内部实现细节）

### 回滚策略
- 如遇到严重问题，可快速回滚到 CSS Grid 实现
- 仅修改一个文件（ProviderGrid.tsx），回滚成本低
- 保留原有 CSS Grid 代码作为注释，方便回滚参考

## Open Questions

**问题 1：是否需要为卡片展开添加过渡动画？**
- 当前状态：未决定
- 建议：先实现基本布局，根据实际体验决定是否添加动画
- 解决时间：实施阶段根据测试结果决定

**问题 2：是否需要支持自定义列数配置？**
- 当前状态：超出范围
- 建议：如未来需要，可通过 Props 传递配置对象
- 解决时间：留待后续需求评估
